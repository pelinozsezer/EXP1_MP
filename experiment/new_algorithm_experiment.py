# import libraries#!pip install psychopyimport osimport sysimport timeimport numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport mathfrom psychopy import gui, core, visual, eventfrom psychopy.gui import DlgFromDictfrom psychopy.core import Clock, quit, waitfrom psychopy.visual import Windowfrom psychopy.hardware import keyboardfrom psychopy.event import Mouse# COLORScolor_gray = [0, 0, 0]color_quartets = [0.9, 0.9, 0.9]  # close to white# window settings#win = visual.Window(size=[1792, 1120], color=color_gray) #units="pix", screen = 0, fullscr=False, allowGUI=True # personal laptop# units="pix", screen = 0, fullscr=False, allowGUI=True # work laptopwin = visual.Window(size=[1512, 982], color=color_gray, units="pix")# keyboard settingskb = keyboard.Keyboard()keys = kb.getKeys(['z', 'm', 'space'], waitRelease=True)## PARAMETERS ##scaler = 1n_trials_training = 4corr_resp_training = 0accuracy_training = 0block_number_experiment = 1trial_number_experiment = 10# MQ parametersstimulus_size =  10*scalerfreq = 2  # 1 cycle or freq is when all the quartets have been shown.# height# width### EXPERIMENTAL PHASE ###experimental_values = range(10,110,10)dynamical_experimental_values = []totalx=experimental_values[-1]# HORIZONTAL LOOPflag_exit_width=0flag_trial=0for width in experimental_values:    if flag_trial==0:        fixation = visual.ShapeStim(win,            vertices=((0, -0.05), (0, 0.05), (0,0), (-0.05,0), (0.05, 0)),            lineWidth=75,            closeShape=False,            lineColor="white"        )            fixation.draw()        win.flip()        core.wait(2)                flag_trial +=1                        # prepare stimuli        height = (totalx/width)  # *scaler                upper_left = visual.Circle(win, radius=stimulus_size, units='pix', pos=(-stimulus_size-(            width/2), stimulus_size+(height/2)), fillColor=color_quartets, lineColor=color_quartets)        upper_right = visual.Circle(win,  radius=stimulus_size, units='pix', pos=(            stimulus_size+(width/2), stimulus_size+(height/2)), fillColor=color_quartets, lineColor=color_quartets)        lower_left = visual.Circle(win,   radius=stimulus_size, units='pix', pos=(-stimulus_size-(            width/2), -stimulus_size-(height/2)), fillColor=color_quartets, lineColor=color_quartets)        lower_right = visual.Circle(win,   radius=stimulus_size, units='pix', pos=(            stimulus_size+(width/2), -stimulus_size-(height/2)), fillColor=color_quartets, lineColor=color_quartets)        stimuli = [upper_left, upper_right, lower_right, lower_left]                kb.getKeys()             duration = 1  # seconds        for i in list(range(0, duration)):                # 1 second            for i in list(range(0, freq)):                    for i in list(range(0, 3, 2)):                    stimuli[i].draw()                win.flip()                core.wait((1/freq)/2)                    for i in list(range(1, 4, 2)):                    stimuli[i].draw()                win.flip()                core.wait((1/freq)/2)            keyPressed = kb.getKeys()         keyPressed_1back=keyPressed[0]        else:                # prepare stimuli        height = (totalx/width)  # *scaler                upper_left = visual.Circle(win, radius=stimulus_size, units='pix', pos=(-stimulus_size-(            width/2), stimulus_size+(height/2)), fillColor=color_quartets, lineColor=color_quartets)        upper_right = visual.Circle(win,  radius=stimulus_size, units='pix', pos=(            stimulus_size+(width/2), stimulus_size+(height/2)), fillColor=color_quartets, lineColor=color_quartets)        lower_left = visual.Circle(win,   radius=stimulus_size, units='pix', pos=(-stimulus_size-(            width/2), -stimulus_size-(height/2)), fillColor=color_quartets, lineColor=color_quartets)        lower_right = visual.Circle(win,   radius=stimulus_size, units='pix', pos=(            stimulus_size+(width/2), -stimulus_size-(height/2)), fillColor=color_quartets, lineColor=color_quartets)        stimuli = [upper_left, upper_right, lower_right, lower_left]            duration = 1  # seconds        for i in list(range(0, duration)):                # 1 second            for i in list(range(0, freq)):                    for i in list(range(0, 3, 2)):                    stimuli[i].draw()                win.flip()                core.wait((1/freq)/2)                    for i in list(range(1, 4, 2)):                    stimuli[i].draw()                win.flip()                core.wait((1/freq)/2)            keyPressed = kb.getKeys()         keyPressed_1back=keyPressed[-1]        if len(kb.getKeys()) > 1:            keyPressed_2back=keyPressed[-2]                    keyPressed_1back            if keyPressed_1back==keyPressed_2back:                continue #continue to next width value            elif keyPressed_1back != keyPressed_2back and (keyPressed_1back == 'm' or keyPressed_1back == 'z'): # percept change                keyPressed_1back=keyPressed_2back                width_idx=experimental_values.index(width)                                # continue until width_idx+1                # prepare stimuli                height = (totalx/experimental_values(width_idx+1))  # *scaler                                upper_left = visual.Circle(win, radius=stimulus_size, units='pix', pos=(-stimulus_size-(                    width/2), stimulus_size+(height/2)), fillColor=color_quartets, lineColor=color_quartets)                upper_right = visual.Circle(win,  radius=stimulus_size, units='pix', pos=(                    stimulus_size+(width/2), stimulus_size+(height/2)), fillColor=color_quartets, lineColor=color_quartets)                lower_left = visual.Circle(win,   radius=stimulus_size, units='pix', pos=(-stimulus_size-(                    width/2), -stimulus_size-(height/2)), fillColor=color_quartets, lineColor=color_quartets)                lower_right = visual.Circle(win,   radius=stimulus_size, units='pix', pos=(                    stimulus_size+(width/2), -stimulus_size-(height/2)), fillColor=color_quartets, lineColor=color_quartets)                stimuli = [upper_left, upper_right, lower_right, lower_left]                            duration = 1  # seconds                for i in list(range(0, duration)):                                # 1 second                    for i in list(range(0, freq)):                                    for i in list(range(0, 3, 2)):                            stimuli[i].draw()                        win.flip()                        core.wait((1/freq)/2)                                    for i in list(range(1, 4, 2)):                            stimuli[i].draw()                        win.flip()                        core.wait((1/freq)/2)                                # now the stimuli need to go back in reverse - shrinking horizontally                dynamical_experimental_values = experimental_values[:width_idx]                dynamical_experimental_values .reverse()                                # SHRINKING HORIZONTALLY                for width in dynamical_experimental_values:                    # prepare stimuli                    height = (totalx/experimental_values(width_idx+1))  # *scaler                                        upper_left = visual.Circle(win, radius=stimulus_size, units='pix', pos=(-stimulus_size-(                        width/2), stimulus_size+(height/2)), fillColor=color_quartets, lineColor=color_quartets)                    upper_right = visual.Circle(win,  radius=stimulus_size, units='pix', pos=(                        stimulus_size+(width/2), stimulus_size+(height/2)), fillColor=color_quartets, lineColor=color_quartets)                    lower_left = visual.Circle(win,   radius=stimulus_size, units='pix', pos=(-stimulus_size-(                        width/2), -stimulus_size-(height/2)), fillColor=color_quartets, lineColor=color_quartets)                    lower_right = visual.Circle(win,   radius=stimulus_size, units='pix', pos=(                        stimulus_size+(width/2), -stimulus_size-(height/2)), fillColor=color_quartets, lineColor=color_quartets)                    stimuli = [upper_left, upper_right, lower_right, lower_left]                                    kb.getKeys()                                        duration = 1  # seconds                    for i in list(range(0, duration)):                                        # 1 second                        for i in list(range(0, freq)):                                            for i in list(range(0, 3, 2)):                                stimuli[i].draw()                            win.flip()                            core.wait((1/freq)/2)                                            for i in list(range(1, 4, 2)):                                stimuli[i].draw()                            win.flip()                            core.wait((1/freq)/2)                                        keyPressed=kb.getKeys()                    keyPressed_1back=keyPressed[-1]                                        keyPressed_1back                    if keyPressed_1back==keyPressed_2back:                        continue                    elif keyPressed_1back != keyPressed_2back and (keyPressed_1back == 'm' or keyPressed == 'z'): # percept change                        keyPressed_1back=keyPressed_2back                                                width_idx = dynamical_experimental_values.index(width)                                                # continue until width_idx+1                        # prepare stimuli                        height = (totalx/experimental_values(width_idx+1))  # *scaler                                                upper_left = visual.Circle(win, radius=stimulus_size, units='pix', pos=(-stimulus_size-(                            width/2), stimulus_size+(height/2)), fillColor=color_quartets, lineColor=color_quartets)                        upper_right = visual.Circle(win,  radius=stimulus_size, units='pix', pos=(                            stimulus_size+(width/2), stimulus_size+(height/2)), fillColor=color_quartets, lineColor=color_quartets)                        lower_left = visual.Circle(win,   radius=stimulus_size, units='pix', pos=(-stimulus_size-(                            width/2), -stimulus_size-(height/2)), fillColor=color_quartets, lineColor=color_quartets)                        lower_right = visual.Circle(win,   radius=stimulus_size, units='pix', pos=(                            stimulus_size+(width/2), -stimulus_size-(height/2)), fillColor=color_quartets, lineColor=color_quartets)                        stimuli = [upper_left, upper_right, lower_right, lower_left]                                            duration = 1  # seconds                        for i in list(range(0, duration)):                                                # 1 second                            for i in list(range(0, freq)):                                                    for i in list(range(0, 3, 2)):                                    stimuli[i].draw()                                win.flip()                                core.wait((1/freq)/2)                                                    for i in list(range(1, 4, 2)):                                    stimuli[i].draw()                                win.flip()                                core.wait((1/freq)/2)                                                # prepare to get out of 'horizontal loop'                        height=dynamical_experimental_values(width_idx+1)                        flag_exit_width=1                        break                                                                                                                                                                            elif flag_exit_width==1:                break   # BE AWARE OF THE PLACEMENT        if flag_exit_width==1:            break    if flag_exit_width==1:        break# VERTICAL LOOP